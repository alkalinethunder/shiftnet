/* * Project: Shiftnet *  * Copyright (c) 2017 Watercolor Games. All rights reserved. For internal use only. *  *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Reflection;using Plex.Objects.ShiftFS;using DynamicLua;using System.Dynamic;using Newtonsoft.Json;using System.Windows.Forms;using System.Threading;using System.Net;using Plex.Objects;namespace Plex.Engine.Scripting{    /// <summary>    /// Brings some C# goodies to the Lua system.    /// </summary>    [Exposed("strutils")]    public class StringUtils    {        /// <summary>        /// Checks if a string ends with a specified string.        /// </summary>        /// <param name="operand">The string to operate on</param>        /// <param name="value">The string to check for</param>        /// <returns>Whether <paramref name="operand"/> ends with <paramref name="value"/>.</returns>        public bool endswith(string operand, string value)        {            return operand.EndsWith(value);        }        /// <summary>        /// Checks if a string starts with a specified string.        /// </summary>        /// <param name="operand">The string to operate on</param>        /// <param name="value">The string to check for</param>        /// <returns>Whether <paramref name="operand"/> starts with <paramref name="value"/>.</returns>        public bool startswith(string operand, string value)        {            return operand.StartsWith(value);        }        /// <summary>        /// Checks if a string contains a specified string.        /// </summary>        /// <param name="operand">The string to operate on</param>        /// <param name="value">The string to check for</param>        /// <returns>Whether <paramref name="operand"/> contains <paramref name="value"/>.</returns>        public bool contains(string operand, string value)        {            return operand.Contains(value);        }    }    /// <summary>    /// DynamicLua wrapper for the Shiftnet engine.    /// </summary>    public class LuaInterpreter    {        /// <summary>        /// The DynamicLua backend.        /// </summary>        public dynamic Lua = new DynamicLua.DynamicLua();        /// <summary>        /// Boolean representing whether the script is running.        /// </summary>        public bool Running = true;                /// <summary>        /// Create a .SFT representation of a Lua script.        /// </summary>        /// <param name="lua">The Lua code to convert</param>        /// <returns>Base64 SFT representation.</returns>        public static string CreateSft(string lua)        {            byte[] bytes = Encoding.UTF8.GetBytes(lua);            return Convert.ToBase64String(bytes);        }        /// <summary>        /// Run a compressed .SFT file as a lua script.        /// </summary>        /// <param name="sft">The .sft file to run.</param>        public static void RunSft(string sft)        {            if (FSUtils.FileExists(sft))            {                try                {                    string b64 = FSUtils.ReadAllText(sft);                    byte[] bytes = Convert.FromBase64String(b64);                    string lua = Encoding.UTF8.GetString(bytes);                    CurrentDirectory = sft.Replace(FSUtils.GetFileInfo(sft).Name, "");                    new LuaInterpreter().Execute(lua);                }                catch                {                    Infobox.Show("Invalid binary.", "This file is not a valid Shiftnet binary executable.");                }            }        }        /// <summary>        /// Get the current working directory of the script.        /// </summary>        public static string CurrentDirectory { get; private set; }        /// <summary>        /// Creates a new instance of the <see cref="LuaInterpreter"/> class.         /// </summary>        public LuaInterpreter()        {            Lua(@"function totable(clrlist)    local t = {}    local it = clrlist:GetEnumerator()    while it:MoveNext() do        t[#t+1] = it.Current    end    return tend");            SetupAPIs();            Application.ApplicationExit += (o, a) =>            {                Running = false;            };        }        /// <summary>        /// Scans the engine, frontend, and all mods for Lua-exposed classes and functions.        /// </summary>        public void SetupAPIs()        {            Lua.currentdir = (string.IsNullOrWhiteSpace(CurrentDirectory)) ? "0:" : CurrentDirectory;            Lua.random = new Func<int, int, int>((min, max) =>            {                return new Random().Next(min, max);            });            Lua.registerEvent = new Action<string, Action<object>>((eventName, callback) =>            {                LuaEvent += (e, s) =>                {                    if (e == eventName)                        try                        {                            callback?.Invoke(s);                        }                        catch(Exception ex)                        {                            Infobox.Show("Event propagation error.", "An error occurred while propagating the " + eventName + " event. " + ex.Message);                        }                };            });            //This temporary proxy() method will be used by the API prober.            Lua.proxy = new Func<string, dynamic>((objName) =>            {                dynamic dynObj = ReflectMan.Types.FirstOrDefault(t => t.Name == objName);                if (dynObj != null)                    return dynObj;                throw new Exception("{CLASS_NOT_FOUND}");            });            foreach (var type in ReflectMan.Types)                foreach (var attr in Array.FindAll(type.GetCustomAttributes(false), a => a is ExposedAttribute))                    Lua($"{(attr as ExposedAttribute).Name} = proxy(\"{type.Name}\")");            //Now we can null out the proxy() method as it can cause security risks.            Lua.isRunning = new Func<bool>(() => { return this.Running; });            Lua.proxy = null;            Lua.invokeOnWorkerThread = new Action<string>((func) =>            {                Desktop.InvokeOnWorkerThread(new Action(() =>                {                    Lua(func + "()");                }));            });            Lua.invokeOnNewThread = new Action<string>((func) =>            {                var t = new Thread(new ThreadStart(() =>                {                    Lua(func + "()");                }));                t.IsBackground = true;                t.Start();            });            Lua.includeScript = new Action<string>((file) =>            {                if (!FSUtils.FileExists(file))                    throw new ArgumentException("File does not exist.");                if (!file.EndsWith(".lua"))                    throw new ArgumentException("File is not a lua file.");                Lua(FSUtils.ReadAllText(file));            });        }        /// <summary>        /// Executes the specified file as an uncompressed Lua script.        /// </summary>        /// <param name="file">The file to execute.</param>        public void ExecuteFile(string file)        {            if (FSUtils.FileExists(file))            {                CurrentDirectory = file.Replace(FSUtils.GetFileInfo(file).Name, "");                Execute(FSUtils.ReadAllText(file));            }            else            {                throw new Exception("The file \"" + file + "\" was not found on the system.");            }        }        /// <summary>        /// Executes the specified string as a Lua script.        /// </summary>        /// <param name="lua">The Lua code to execute.</param>        public void Execute(string lua)        {            try            {                Console.WriteLine("");                Lua(lua);            }            catch (Exception e)            {                Infobox.Show("Script error", $@"Script threw {e.GetType().Name}:{e.Message}");            }        }        /// <summary>        /// Occurs when a Lua event is fired by C#.        /// </summary>        private static event Action<string, object> LuaEvent;        /// <summary>        /// Raises a Lua event with the specified name and caller object.        /// </summary>        /// <param name="eventName">The name of the event. Scripts use this to check what type of event occurred.</param>        /// <param name="caller">The caller of the event. Scripts can use this to check if they should handle this event.</param>        public static void RaiseEvent(string eventName, object caller)        {            LuaEvent?.Invoke(eventName, caller);        }    }    /// <summary>    /// Marks the specified class as a Lua API object.    /// </summary>    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]    public class ExposedAttribute : Attribute    {        /// <summary>        /// If applied to a non-static class, the Shiftnet engine will see this class as a Lua object of the specified name.        /// </summary>        /// <param name="name">The name of the Lua object</param>        public ExposedAttribute(string name)        {            Name = name;        }        /// <summary>        /// The API object's name        /// </summary>        public string Name { get; private set; }    }}